# options.toml: This file contains general options for the code

# parallel: Whether or not to utilize multiple CPUs to fit spaxels in parallel
parallel = true

# parallel_strategy: "pmap" or "distributed". Generally pmap is superior as it balances the work load
# between processes, whereas distributed simply allocates an equal amount of jobs to each CPU.
parallel_strategy = "pmap"

# plot_spaxels: The plotting backend for 1D spaxel fits. Can be "pyplot", "plotly", or "both".
plot_spaxels = "pyplot"

# plot_maps: Whether or not to plot 2D parameter maps at the end of fitting.
plot_maps = true

# save_fits: Whether or not to save the model parameters and the model itself as FITS files at the end of fitting.
save_fits = true

# save_tables: Whether or not to save the model parameters as CSV tables at the end of fitting.
save_tables = true

# lines_allow_negative: Whether or not to allow the amplitudes of emission lines to go negative. Disabled by default.
# This also changes the units of the output for line amplitudes and fluxes from log10(erg/s/cm2) to erg/s/cm2.
lines_allow_negative = false

# n_bootstrap: The number of bootstrapping iterations to perform during fitting, which
# is used to estimate the uncertainties on parameters given the uncertainties in the data.
n_bootstrap = 0

# random_seed: Set the random seed for bootstrapping
random_seed = 123456789

# overwrite: This controls what to do in case the fit for a certain spaxel
# has already been performed / saved.  If true, the fit will be performed again
# and the old one will be overwritten.  Otherwise, it won't.
overwrite = false

# track_memory: This controls whether an additional log file is saved for each
# spaxel which specifically tracks the memory usage / allocations during the
# spaxel fitting. Useful if memory usage is higher than expected.
track_memory = false

# track_convergence: Similarly, this controls whether an additional log file is
# generated which prints convergence information for each spaxel fit (but only
# for the LINE fit). Be warned that the way Optim.jl works with the simulated
# annealing method SAMIN makes it always print "status: failure" even if convergence
# was reached. The way to tell whether convergence was ACTUALLY reached is if
# the number of iterations reached the maximum (which is 10^6 by default).
track_convergence = true

# make_movies: Whether or not to save mp4 files of the data and final models of
# IFU cubes. This option require the user to have FFMPeg (https://ffmpeg.org/),
# as well as the FFMPeg and Astropy python packages, installed on their system.
# These are not necessarily scientifically useful, but they're pretty to watch.
make_movies = false

# save_full_model: Whether or not to save the full model of each spaxel in IFU cube
# format. If false, the model parameters will still be saved (the model can be
# easily reconstructed by simply rerunning the code with this option enabled, as the
# fitting data for each spaxel will already be saved)
save_full_model = true

# sys_err: Optional systematic error to add in quadrature. I.e. sys_err = 0.1 adds a 10%
# systematic error.
sys_err = 0.0

# map_snr_thresh: The SNR threshold below which to mask out spaxels when plotting parameter maps
map_snr_thresh = 3.0

# silicate_absorption: May be "kvt" for the Kemper, Vriend, & Tielens (2004) 
# extinction profile, "ct" for the Chiar & Tielens (2005) extinction profile,
# "ohm" for the Ossenkopf, Henning, & Mathis (1992) extinction profile, or "d+" for the 
# Donnan et al. (2022) extinction profile.
# May also be "decompose" to fit as a combination of amorphous olivine, pyroxene, and crystalline forsterite absorption
# Note that for combined optical+IR fitting, only "kvt" and "d+" are supported here because the 
# other templates also include other types of extinction which are covered by the calzetti/CCM curves
silicate_absorption = "d+"
# optical options: may be either "calz" for the Calzetti et al. (2000) starburst galaxy curve,
# or "ccm" for the Cardelli, Clayton, & Mathis (1989) Milky Way curve.
extinction_curve = "calz"

# Polynomials degrees: 
# "apoly_degree" sets the degree for additive polynomials.
# "mpoly_degree" sets the degree for multiplicative polynomials.
# If either degrees are less than 0, the polynomials components are disabled (this is the default).
# For multiplicative polynomials specifically, the 0th degree is disabled, since it is degenerate with
# the normalization of the other fitting components.  Therefore, to actually include a multiplicative 
# polynomial, the degree must be at least 1. The same restriction does NOT apply to additive polynomials.
#
# BE CAREFUL when enabling polynomial components.  Most of the model component options in Loki are at
# least somewhat physically motivated.  Polynomials are not, and are treated conceptually as
# "calibration corrections" to your continuum model.  For example, additive polynomials can be a good
# way to subtract out a foreground/background signal, whereas multiplicative polynomials can be a good
# way to model a non-uniform flux calibration as a function of wavelength from your instrument. 
# They can be very powerful fitting tools, but as they say, "with great power comes great responsibility."
# Just as one example, I would not recommend that you marginalize over any kind of extinction/reddening
# at the same time as multiplicative polynomials, because they will inevitably be degenerate.
# (Check the optical.toml file for options on setting the bounds of the polynomial coefficients)
#
# Multiplicative polynomials act on everything EXCEPT:
#  - Emission lines (including the Fe II templates)
#  - PAHs (unless you are using PAH templates, in which case the polynomials are applied
#          during the template fitting, but not during the Drude profile fitting)
#  - Additive polynomials
# Additive polynomials are also not affected by dust extinction.
#
apoly_degree = -1
mpoly_degree = -1

# These options set the type of polynomial to use for additive or multiplicative polynomials.
# The options are:
#   - "Chebyshev"
#   - "Legendre"
apoly_type = "Chebyshev"
mpoly_type = "Chebyshev"

# The following 3 options are only used if extinction_screen = "decompose"
# Magnesium content for olivine 
olivine_y = 0.5
# Magnesium content for pyroxene
pyroxene_x = 0.5
# Olivine and pyroxene grain sizes (in microns)
grain_size = 0.1

# extinction_screen: Controls whether extinction is modeled as e^-tau (true) or
# (1 - e^-tau) / tau (false), following PAHFIT.
extinction_screen = true

# whether or not to fit the stellar continuum
fit_stellar_continuum = true

# the regularization value for the SSPs, if they are being fit.
# set to 0 to disable regularization
ssp_regularize = 100.0

# whether or not to fit optical Fe II emission (obviously only applies for optical spectra)
# separate options for narrow- and broad-line templates
fit_opt_na_feii = false
fit_opt_br_feii = false

# whether or not to fit silicate emission
fit_sil_emission = false

# whether or not to fit the CH + water ice absorption features at ~7 um
fit_ch_abs = false

# whether or not to fit multiplicative exponential profiles to any provided templates
fit_temp_multexp = false

# whether or not to constrain the PAH emission using templates from Smith et al. (2007)
use_pah_templates = true

# fit_joint: this option decides whether or not lines should be fit jointly with the continuum. If false,
# the lines will first be masked out during the continuum fitting, and then the continuum model will be 
# subtracted during the line fitting. If true, the continuum and lines are fit simultaneously. This option
# is incompatible with the use_pah_templates option (only one may be true at a time).
# Note: It is recommended to use FALSE for fitting MIR data, and TRUE for fitting optical data.
fit_joint = false

# whether or not to use global optimization on ALL spaxels (if false, only uses it for the initial fit
# to the sum of all spaxels, and subsequent individual-spaxel fits are only done with a local Lev-Mar fit,
# which is typically sufficient as long as the lines one wishes to fit are prominent in the sum of all spaxels).
# If fitting lines with multiple velocity components, global optimization can be a good idea since they can be
# degenerate. The global optimizer is an adaptive particle swarm algorithm.
fit_all_global = false

# whether or not to fit the UV bump for the calzetti attenuation curve
fit_uv_bump = false

# whether or not to fit a dust covering fraction for the calzetti attenuation curve
fit_covering_frac = false

# whether or not template amplitudes should be tied between different channels - the default (false) means that a
# template may have different normalizations in each subchannel in the fit, allowing it to fit jumps in the continuum.
tie_template_amps = false

# this option, if enabled, will lock the relative abundances of olivine, pyroxene, and forsterite to the values obtained
# from the initial fit to the integrated spectrum (the overall normalization may still change).
decompose_lock_column_densities = true

user_mask = []

# which lines should be tested for additional components
line_test_lines = []

# a threshold value on the F-value (https://en.wikipedia.org/wiki/F-test#:~:text=An%20F%2Dtest%20is%20any,which%20the%20data%20were%20sampled) 
# to determine how significant additional line components must be in order to include them in a fit.
# Smaller threshold -> lines must be more significant to be added
line_test_threshold = 0.003

# the default width (in km/s) to mask out to the left/right of each line in the line list
linemask_width = 1000.0

# whether or not to plot the results of line testing
plot_line_test = true

# whether or not to subtract a cubic spline fit to the continuum instead of the real fit to the continuum during
# the line fitting step
subtract_cubic_spline = false

# This is a very weird option but basically: if you're using templates for the PSF and the PSF templates take up most 
# of the amplitude of the continuum, it can cause the extinction to be driven unphysically high since it has a small effect.
# If this happens, the code tries to automatically redo the fit with the extinction locked to 0.
# If you set F_test_ext = true, then when this happens, the code will perform an F-test on the fit with the extinction locked
# to 0 vs the fit with the extinction unlocked and determine if the extinction is actually statistically significant, and it
# will only use the results with the extinction if there is a significant statistical improvement in the fit.
F_test_ext = false

# Stellar template type
# - "ssp" (default): Fit the stellar continuum using simple stellar populations (SSPs)
# - "stars"        : Fit the stellar continuum using single star templates (model atmospheres)
# - "custom"       : Fit the stellar continuum using custom (user-input) templates
#
# When to use which option?
# - "ssp" is good for getting stellar mass, age, and metalllicity estimates, as it is the only fitting mode
#   that allows for the estimation of these parameters.  It has a wide usable wavelength coverage, from ~1800 A in
#   the FUV to ~30 um in the MIR, at an acceptable resolution. However, it is a bit more restrictive than the other 
#   options in terms of the flexibility of the stellar continuum, so fitting quality results may vary.
#
# - "stars" is the highest resolution option, but is limited in wavelength from ~6000 A to ~5.5 um. This option
#   allows for high-quality fits to stellar spectra, and in particular stellar velocities, in the red-optical to NIR, 
#   designed to be ideal for JWST/NIRSpec.  However, it does not allow for the estimation of stellar masses, ages, or
#   metallicities.
#
# - "custom" is for use-cases where you have your own templates which are more tailor-made for your specific
#   use case which you'd like to use.
#
stellar_template_type = "ssp"

# SSP options: Controls the grid spacing for the simple stellar populations over age and metallicity
# Obviously, this only matters if the "stellar_template_type" is set to "ssp"
[ssps]

# (Ages are in Gyr)
[ssps.age]
min = 0.001
max = 13.7 
num = 40

# (Metallicities are in log(Z/Zsun))
[ssps.logz]
min = -2.3
max = 0.4
num = 10

# Single Star options: Limit the single star templates in Teff, logg, Z, or alpha enhancement.
# This functionality is provided because, by default, there are many thousands of single star templates,
# and marginalizing over *all* of them is not only unnecessary, but will severely slow down fitting in 
# the single star mode.
# Obviously, this only matters if the "stellar_template_type" is set to "stars" 
[stars]

# This option determines which library to use for "cool" stars (Teff < 10,000 K).
# There are two options:
#   - "phoenix_btsettl" (default): The PHOENIX BT-Settl grid of models by Allard et al. 2012
#   - "phoenix_husser"           : The PHOENIX grid of models by Husser et al. 2013
#
# Which one should you use?  Well, there isn't one clear answer, which is why I provide both.
# Some notable differences:
#   - The Husser grids do not extend past 5.5 microns, while the BT-Settl grids do (at a low resolution).
#     Otherwise, they have been resampled onto the same wavelength grid with the same resolution.
#   - The BT-Settl grids extend to lower Teff than the Husser grids, and are specialized for
#     modeling cool stars, including the transition to brown dwarfs and planets.  They go all the way 
#     down to 400 K, while the Husser grids only go to 2300 K.
#   - The Husser grids have more complete coverage in alpha enhancement, ranging from -0.2 to +1.2 over
#     a broad range of metallicites.  The BT-Settl models instead opt for only providing grid points at 
#     the most common alpha values -- so lower metallicity stars only have alpha=+0.4, while solar metallicity
#     stars only have alpha=0.  This is important when selecting limits on alpha!  
#     ***DO NOT RESTRICT ALPHA VALUES WHEN USING THE BT-SETTL GRIDS*** otherwise you may unintentionally
#     eliminate the majority of your parameter space.
cool_lib = "phoenix_btsettl"

# (boolean options for whether or not to include additional templates for 
# Wolf-Rayet stars and/or thermally pulsing AGB stars)
use_wr = false
use_tpagb = false

# (effective temperature)
# absolute minimum:
#   BT-Settl:    400 K
#   Husser  :  2,300 K
#   TLUSTY  : 10,000 K
# absolute maximum:
#   BT-Settl:  10,000 K
#   Husser  :  10,000 K
#   TLUSTY  : 250,000 K
# --------
# Note: I have manually cut off the "cool" libraries
# at 10,000 K and supplemented them with the hot TLUSTY 
# library, which extends from 10,000 K up to 250,000 K.
# The TLUSTY stars are always included alongside whichever
# cool library you choose, as they cover different parameter
# spaces.  I provide this mostly as a convenience for those
# looking to fit optical/UV spectra, but these hotter stars
# should be essentially negligible for those working with
# NIR or longer wavelength data, so the default temperature
# cutoff is a modest 7000 K.
[stars.teff]
min = 2000.0
max = 7000.0

# (gravity)
# absolute minimum:
#   BT-Settl: -0.5
#   Husser  :  0.0
#   TLUSTY  : +2.0
# absolute maximum:
#   BT-Settl: +6.0
#   Husser  : +6.0
#   TLUSTY  : +8.5
[stars.logg]
min = -0.5
max = +5.0

# (metallicity)
# absolute minimum:
#   BT-Settl: -4.0
#   Husser  : -4.0
#   TLUSTY  : -2.0
# absolute maximum:
#   BT-Settl: +0.5
#   Husser  : +1.0
#   TLUSTY  :  0.0
[stars.logz]
min = -2.0
max = +0.5

# (alpha enhancement)
# absolute minimum:
#   BT-Settl: -0.2
#   Husser  : -0.2
#   TLUSTY  :  0.0
# absolute maximum:
#   BT-Settl: +0.6
#   Husser  : +1.2
#   TLUSTY  :  0.0
# --------
# Note: If using BT-Settl grids, I STRONGLY suggest you
# keep the limits at -0.2 to +0.6, because they do not have
# fully independent coverage across metallicity and alpha.
# For example, the logz=-2 grids only have alpha=+0.4,
# whereas the logz=+0.3 grids only have alpha=0.
# The Husser grids DO have full independent coverage (for
# the most part), so feel free to edit these however you
# like when using the Husser grids.
[stars.alpha]
min = -0.2
max = +0.6

# cosmology options: Controls the cosmology used for distance / luminosity calculations.
# If h is set to 1, the distances in plot scale bars will be shown with h^-1 units.
[cosmology]
h = 0.7           # Hubble constant (in km s^-1 Mpc^-1) / 100
omega_m = 0.27    # matter density parameter
omega_K = 0.0     # curvature density parameter
omega_r = 0.0     # radiation density parameter
