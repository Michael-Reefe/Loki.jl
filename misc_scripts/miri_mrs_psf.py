import matplotlib.pyplot as plt
import numpy as np
from astropy.io import fits
from astropy.wcs import WCS
from scipy import ndimage
import photutils
import reproject
import webbpsf
import tqdm
import toml
import sys
import os


#### This script exists as a tool that can be used to apply JWST PSF corrections to line flux maps generated by LOKI 
#### This is achieved using the webbpsf python package, which currently does not support MIRI MRS observations, but 
#### there is a development version that partially supports these modes. This script will take an input parameter maps
#### FITS file from LOKI and add additional header/data units for the separated point-like and extended emission for
#### each line. However, note that some additional inputs are also required. Notably, one needs IFU-aligned, single-channel,
#### single-band, level 3 reduced data cubes from the JWST pipeline (the IFU-aligned axes can be achieved by setting
#### spec3.cube_build.coord_system = 'ifualign')


def calculate_mrs_psf(ifu_cube, wave=None, out_wcs=None, out_shape=None, oversample=4, broadening='both', debug=False):
    """
    Calculate the point-spread function of the MIRI Medium Resolution Spectrometer (MRS) IFU unit, using
    an in-development version of webbpsf, for a given observation. The PSFs are calculated at the peak
    brightness location of the input FITS image.
    
    :param ifu_cube: HDUList
        The FITS object containing MIRI MRS IFU data. Note that this must be a level 3 reduced cube, and the
        axes must be IFU-aligned and not sky-aligned, otherwise the PSF will not be generated at the correct spot.
    :param oversample: int
        Oversampling factor to be passed to webbpsf
    :param broadening: str
        Include broadening of PSF for MIRI MRS. May be None or 'both' for broadening in the alpha and beta axes.
    :param debug: bool
        Set to true to show plots of the PSFs as they are calculated.
    """
    # Object name
    name = ifu_cube[0].header['TARGNAME']
    name = name.replace(' ', '_').lower()

    # Get channel/band information
    channel = ifu_cube[0].header['CHANNEL']
    band = ifu_cube[0].header['BAND']
    detector = ifu_cube[0].header['DETECTOR']
    assert channel in ('1', '2', '3', '4'), f"Unrecognized channel: {channel}, please only input single-channel cubes"
    assert band in ('SHORT', 'MEDIUM', 'LONG'), f"Unrecognized band: {band}, please only input single-band cubes"
    assert detector in ('MIRIFUSHORT', 'MIRIFULONG'), f"Unrecognized detector: {detector}, please only input single-detector cubes"

    # Get wavelength array
    hdr = ifu_cube[1].header
    wave_full = hdr["CRVAL3"] + hdr["CDELT3"] * (hdr["CRPIX3"] + np.arange(hdr["NAXIS3"]) - 1)
    if wave is None:
        wave = wave_full
    if type(wave) in (float, int):
        wave = [wave]

    # Get the field of view in arcseconds
    pix_as = np.sqrt(hdr["PIXAR_A2"])
    # pix_as = {'1': 0.13, '2': 0.17, '3': 0.2, '4': 0.34}[channel]
    fov_as = np.array(ifu_cube[1].data.shape[1:]) * pix_as

    # Get the rotation angle w/r/t sky coordinates
    hdr = ifu_cube[1].header
    costheta = -hdr["PC1_1"]  # (negative because of the flipped RA axis)
    sintheta = -hdr["PC1_2"]  # (negative because of how the rotation matrix is defined)
    theta_rad = np.arctan2(sintheta, costheta)
    theta = theta_rad * 180/np.pi
    assert theta != 0.0, "Please input an IFU-coordinate aligned cube, not a sky-coordinate aligned cube!"

    print("\n")
    print("################## Target Information #################")
    print(f"Target: {name}\nChannel: {channel}\nBand: {band}\nDetector: {detector}")
    print(f"Wavelength coverage: ({np.min(wave):.2f}, {np.max(wave):.2f}) microns")
    print(f"Rotation angle to sky axes: {theta:.2f} deg")
    print("#######################################################")
    print("\n")

    print("Setting up MIRI detector object")

    # Set up MIRI object with the IFU configurations
    miri = webbpsf.MIRI()

    # Configure for the proper channel/band setup
    assert (f'MIRI-IFU_{channel}' in miri.image_mask_list) and (f'D{band}' in miri.filter_list), "Channel/Band setup not found in webbpsf " + \
         "MIRI options. Please make sure you are using a version of webbpsf that supports MIRI MRS mode."
    miri.image_mask = f'MIRI-IFU_{channel}'
    miri.filter = f'D{band}'
    miri.detector = detector
    miri.pixelscale = pix_as

    centroids = []
    for wavei in wave:
        wave_slice = np.argmin(np.abs(wavei - wave_full))
        centroid = photutils.centroids.centroid_com(ifu_cube[1].data[wave_slice, :, :])
        centroids.append(centroid)
    centroid_x = np.mean([cent[0] for cent in centroids])
    centroid_y = np.mean([cent[1] for cent in centroids])

    # Adjust the position of the source to match the source in the data
    center_y, center_x = np.array(ifu_cube[1].data.shape[1:]) / 2
    offset_x_as = (centroid_x + 0.5 - center_x) * pix_as
    offset_y_as = (centroid_y + 0.5 - center_y) * pix_as
    miri.options['source_offset_x'] = offset_x_as
    miri.options['source_offset_y'] = offset_y_as
    print(f"Source position offset: {offset_x_as:.3f}\", {offset_y_as:.3f}\"")

    # Prepare output array
    psf_cube = np.zeros((len(wave), *ifu_cube[1].data.shape[1:]))

    print("Generating PSF models with webbpsf for each wavelength slice (this may take a while)...")
    if debug:
        fig, ax = plt.subplots()
        cdata = ax.imshow(np.full(psf_cube.shape[1:], fill_value=-5.0, dtype=float), origin='lower', cmap='cubehelix', vmin=-5, vmax=0)
        fig.colorbar(cdata)

    for i in tqdm.trange(len(wave)):

        # Calculate the PSF
        psf = miri.calc_psf(monochromatic=wave[i], broadening=broadening, add_distortion=False, 
                            oversample=oversample, display=False, fov_arcsec=fov_as, crop_psf=True)
        
        # Normalize so that it integrates to 1
        psf_norm = psf[3].data / np.sum(psf[3].data)
        # Add to output array
        psf_cube[i, :, :] = psf_norm

        if debug:
            cdata.set_data(np.log10(psf_cube[i, :, :]))
            plt.draw()
            plt.pause(0.01)
    
    if psf_cube.shape[0] == 1:
        psf_cube = psf_cube[0, :, :]
    
    # Reproject onto output WCS
    if out_wcs is not None:
        in_wcs = WCS(ifu_cube[1].header)[0]
        psf_cube = reproject.reproject_interp((psf_cube, in_wcs), out_wcs, out_shape, order='bilinear', return_footprint=False)

    if debug:
        plt.close()

    # Return the PSF cube object 
    return psf_cube


def calculate_extended_emission(ifu_cubes, params, line_dict):
    """
    Loop through all line fluxes in the parameter maps and calculate separated nuclear (point-like) flux from
    extended flux using the PSF. Creates new HDUs for both of the separated fluxes.

    :param ifu_cubes: dict
        A dictionary of FITS HDULists for each MIRI channel/band. Should be IFU-aligned axes. These are used to
        calculate the position of the point source and the rotation between the IFU axes and sky axes.
    :param params: HDUList
        The parameter maps containing the line fluxes that should be corrected.
    :param line_dict: dict
        A dictionary containing the rest wavelengths of the lines.
    """

    z = params[0].header['REDSHIFT']
    
    ch_dict = {'1A': (4.90, 5.74),
               '1B': (5.66, 6.63),
               '1C': (6.53, 7.65),
               '2A': (7.51, 8.77),
               '2B': (8.67, 10.13),
               '2C': (10.02, 11.70),
               '3A': (11.55, 13.47),
               '3B': (13.34, 15.57),
               '3C': (15.41, 17.98),
               '4A': (17.70, 20.95),
               '4B': (20.69, 24.48),
               '4C': (24.19, 27.90)}
    
    out_wcs = WCS(params[0].header)[0]
    out_shape = params[1].data.shape
    names = [param.name for param in params]

    for param in params:

        # Correct all line flux maps
        if ('lines' in param.name) and ('flux' in param.name):

            # Loop through lines dictionary to find the rest wavelenth
            line_wave = None
            for key in line_dict['lines'].keys():
                if key in param.name:
                    line_wave = line_dict['lines'][key]['wave']
            if line_wave is None:
                raise ValueError(f'Could not find line entry for {param.name}')
            # Convert to observed-frame wavelength
            line_wave *= (1+z)
            # Get the MIRI Channel/Band that this falls under
            chbands = []
            for key, val in ch_dict.items():
                if val[0] < line_wave < val[1]:
                    chbands.append(key)
            # Generate PSFs for each channel/band
            psfs = []
            for chband in chbands:
                psf = calculate_mrs_psf(ifu_cubes[chband], line_wave, out_wcs, out_shape)
                psf /= np.nanmax(psf)
                psfs.append(psf)
            # For lines that happen to fall on the channel boundaries, average the two PSFs
            if len(psfs) > 1:
                psf = np.nanmean(psfs, axis=0)
            else:
                psf = psfs[0]
                
            # For logarithmic quantities make sure to undo the log before correcting
            flux = 10**param.data
            flux_nuc = np.nanmax(flux)
            # Redo the log
            flux_point = np.log10(psf*flux_nuc)
            flux_ext = np.log10(flux - psf*flux_nuc)

            # Make a new HDU with the corrected flux
            if param.name.upper() + '_POINT' not in names:
                flux_point = fits.ImageHDU(flux_point, param.header, name=param.name.upper() + '_POINT')
                params.append(flux_point)
            else:
                params[param.name.upper() + '_POINT'].data = flux_point
            if param.name.upper() + '_EXTENDED' not in names:
                flux_ext = fits.ImageHDU(flux_ext, param.header, name=param.name.upper() + '_EXTENDED')
                params.append(flux_ext)
            else:
                params[param.name.upper() + '_EXTENDED'].data = flux_ext

    return params


if __name__ == '__main__':

    # Inputs: file paths to (1) IFU-aligned single-channel single-band level 3 reduced cubes,
    #                       (2) Parameter maps FITS file
    ifu_path = sys.argv[1]
    param_path = sys.argv[2]
    line_dict_path = os.path.join(os.path.dirname(__file__), '..', 'src', 'options', 'lines.toml')

    # Get IFU-aligned cubes for each subchannel
    print('Loading in FITS data...')
    ifu_cubes = {'1A': fits.open(os.path.join(ifu_path, 'Level3_ch1-short_s3d.fits')),
                 '1B': fits.open(os.path.join(ifu_path, 'Level3_ch1-medium_s3d.fits')),
                 '1C': fits.open(os.path.join(ifu_path, 'Level3_ch1-long_s3d.fits')),
                 '2A': fits.open(os.path.join(ifu_path, 'Level3_ch2-short_s3d.fits')),
                 '2B': fits.open(os.path.join(ifu_path, 'Level3_ch2-medium_s3d.fits')),
                 '2C': fits.open(os.path.join(ifu_path, 'Level3_ch2-long_s3d.fits')),
                 '3A': fits.open(os.path.join(ifu_path, 'Level3_ch3-short_s3d.fits')),
                 '3B': fits.open(os.path.join(ifu_path, 'Level3_ch3-medium_s3d.fits')),
                 '3C': fits.open(os.path.join(ifu_path, 'Level3_ch3-long_s3d.fits')),
                 '4A': fits.open(os.path.join(ifu_path, 'Level3_ch4-short_s3d.fits')),
                 '4B': fits.open(os.path.join(ifu_path, 'Level3_ch4-medium_s3d.fits')),
                 '4C': fits.open(os.path.join(ifu_path, 'Level3_ch4-long_s3d.fits'))}
    # Get the parameter maps from the fitting
    params = fits.open(param_path, mode='update')
    # Get the line dictionary so we can get rest wavelengths based on the HDU names
    line_dict = toml.load(line_dict_path)

    params = calculate_extended_emission(ifu_cubes, params, line_dict)

    # Write changes to the file and close
    params.flush()
    params.close()
    for val in ifu_cubes.values():
        val.close()
