import matplotlib.pyplot as plt
import numpy as np
from astropy.io import fits
from astropy.wcs import WCS
from scipy import ndimage
import photutils
import reproject
import webbpsf
import tqdm
import toml
import sys
import os


#### This script exists as a tool that can be used to apply JWST PSF corrections to line flux maps generated by LOKI 
#### This is achieved using the webbpsf python package, which currently does not support MIRI MRS observations, but 
#### there is a development version that partially supports these modes. This script will take an input parameter maps
#### FITS file from LOKI and add additional header/data units for the separated point-like and extended emission for
#### each line. However, note that some additional inputs are also required. Notably, one needs IFU-aligned, single-channel,
#### single-band, level 3 reduced data cubes from the JWST pipeline (the IFU-aligned axes can be achieved by setting
#### spec3.cube_build.coord_system = 'ifualign')

#### Another option is to calculate the PSF models for all wavelength slices in a given channel/band. This can be achieved
#### by inputting a LOKI/JWST-formatted sky-aligned input model instead of a parameter maps FITS file, and specifying the 
#### channel/band to compute the models for, i.e. '1A', '3C', etc. (Warning: This may take a while, as each model takes ~3-5 seconds
#### to generate)


def calculate_mrs_psf(ifu_cube, centroid=None, wave=None, out_wcs=None, out_shape=None, oversample=4, broadening='both', debug=False,
                      shift_to=None, shift_wcs=None):
    """
    Calculate the point-spread function of the MIRI Medium Resolution Spectrometer (MRS) IFU unit, using
    an in-development version of webbpsf, for a given observation. The PSFs are calculated at the peak
    brightness location of the input FITS image.
    
    :param ifu_cube: HDUList
        The FITS object containing MIRI MRS IFU data. Note that this must be a level 3 reduced cube, and the
        axes must be IFU-aligned and not sky-aligned, otherwise the PSF will not be generated at the correct spot.
    :param oversample: int
        Oversampling factor to be passed to webbpsf
    :param broadening: str
        Include broadening of PSF for MIRI MRS. May be None or 'both' for broadening in the alpha and beta axes.
    :param debug: bool
        Set to true to show plots of the PSFs as they are calculated.
    """
    # Object name
    name = ifu_cube[0].header['TARGNAME']
    name = name.replace(' ', '_').lower()

    # Get channel/band information
    channel = ifu_cube[0].header['CHANNEL']
    band = ifu_cube[0].header['BAND']
    detector = ifu_cube[0].header['DETECTOR']
    assert channel in ('1', '2', '3', '4'), f"Unrecognized channel: {channel}, please only input single-channel cubes"
    assert band in ('SHORT', 'MEDIUM', 'LONG'), f"Unrecognized band: {band}, please only input single-band cubes"
    assert detector in ('MIRIFUSHORT', 'MIRIFULONG'), f"Unrecognized detector: {detector}, please only input single-detector cubes"

    # Get wavelength array
    hdr = ifu_cube[1].header
    wave_full = hdr["CRVAL3"] + hdr["CDELT3"] * (hdr["CRPIX3"] + np.arange(hdr["NAXIS3"]) - 1)
    if wave is None:
        wave = wave_full
    if type(wave) in (float, int):
        wave = [wave]

    # Get the field of view in arcseconds
    pix_as = np.sqrt(hdr["PIXAR_A2"])
    # pix_as = {'1': 0.13, '2': 0.17, '3': 0.2, '4': 0.34}[channel]
    fov_as = np.array(ifu_cube[1].data.shape[1:]) * pix_as

    # Get the rotation angle w/r/t sky coordinates
    hdr = ifu_cube[1].header
    costheta = -hdr["PC1_1"]  # (negative because of the flipped RA axis)
    sintheta = -hdr["PC1_2"]  # (negative because of how the rotation matrix is defined)
    theta_rad = np.arctan2(sintheta, costheta)
    theta = theta_rad * 180/np.pi
    assert theta != 0.0, "Please input an IFU-coordinate aligned cube, not a sky-coordinate aligned cube!"

    print("\n")
    print("################## Target Information #################")
    print(f"Target: {name}\nChannel: {channel}\nBand: {band}\nDetector: {detector}")
    print(f"Wavelength coverage: ({np.min(wave):.2f}, {np.max(wave):.2f}) microns")
    print(f"Rotation angle to sky axes: {theta:.2f} deg")
    print("#######################################################")
    print("\n")

    print("Setting up MIRI detector object")

    # Set up MIRI object with the IFU configurations
    miri = webbpsf.MIRI()

    # Configure for the proper channel/band setup
    assert (f'MIRI-IFU_{channel}' in miri.image_mask_list) and (f'D{band}' in miri.filter_list), "Channel/Band setup not found in webbpsf " + \
         "MIRI options. Please make sure you are using a version of webbpsf that supports MIRI MRS mode."
    miri.image_mask = f'MIRI-IFU_{channel}'
    miri.filter = f'D{band}'
    miri.detector = detector
    miri.pixelscale = pix_as

    # Prepare output array
    psf_cube = np.zeros((len(wave), *ifu_cube[1].data.shape[1:]))

    print("Generating PSF models with webbpsf for each wavelength slice (this may take a while)...")
    if debug:
        fig, ax = plt.subplots()
        cdata = ax.imshow(np.full(psf_cube.shape[1:], fill_value=-5.0, dtype=float), origin='lower', cmap='cubehelix', vmin=-5, vmax=0)
        fig.colorbar(cdata)


    if centroid is None:
        centroid_x, centroid_y = photutils.centroids.centroid_2dg(np.nansum(ifu_cube['SCI'].data, axis=0),
                                                                  error=np.sqrt(np.nansum(ifu_cube['ERR'].data**2, axis=0)))
    else:
        centroid_x, centroid_y = centroid

    # Adjust the position of the source to match the source in the data
    center_y, center_x = np.array(ifu_cube[1].data.shape[1:]) / 2
    offset_x_as = (centroid_x + 0.5 - center_x) * pix_as
    offset_y_as = (centroid_y + 0.5 - center_y) * pix_as
    miri.options['source_offset_x'] = offset_x_as
    miri.options['source_offset_y'] = offset_y_as
    print(f"Source position offset: {offset_x_as:.3f}\", {offset_y_as:.3f}\"")

    for i in tqdm.trange(len(wave)):

        # Calculate the PSF
        try:
            psf = miri.calc_psf(monochromatic=wave[i], broadening=broadening, add_distortion=False, 
                                oversample=oversample, display=False, fov_arcsec=fov_as, crop_psf=True)
        except:
            # This is dumb but it works for some reason
            miri.pixelscale = pix_as
            psf = miri.calc_psf(monochromatic=wave[i], broadening=broadening, add_distortion=False, 
                                oversample=oversample, display=False, fov_arcsec=fov_as, crop_psf=True)
        
        # Normalize so that the maximum is 1
        psf_norm = psf[3].data / np.nanmax(psf[3].data)
        # Add to output array
        psf_cube[i, :, :] = psf_norm

        if debug:
            cdata.set_data(np.log10(psf_cube[i, :, :]))
            plt.draw()
            plt.pause(0.01)
    
    if psf_cube.shape[0] == 1:
        psf_cube = psf_cube[0, :, :]
    
    # Reproject onto output WCS
    if out_wcs is not None:
        print("Reprojecting PSF onto output grid...")
        in_wcs = WCS(ifu_cube[1].header)[0]
        psf_cube = rotate_and_shift(psf_cube, in_wcs, out_wcs, out_shape, shift_to=shift_to, shift_wcs=shift_wcs)

    if debug:
        plt.close()

    # Return the PSF cube object 
    return psf_cube


def rotate_and_shift(psf, in_wcs, out_wcs, out_shape, shift_to=None, shift_wcs=None):
    """
    Reproject the PSF model onto another coordinate system, given an input and output WCS and an output shift.
    Also optionally shift the PSF so the centroid matches with the centroid of a given FITS file.

    :param psf: np.ndarray
        The 3D PSF model, in IFU coordinates
    :param in_wcs: WCS
        The WCS for the input PSF model
    :param out_wcs: WCS
        The output WCS for the PSF to be projected onto
    :param out_shape: iterable
        The output shape for the PSF to be projected onto
    :param shift_to: HDUList, optional
        A FITS HDUList object containing data that can be centroided, such that the centroids can be matched and aligned.
    """
    
    print('Reprojecting PSFs onto the output coordinate frame...')
    psf_rot = reproject.reproject_interp((psf, in_wcs), out_wcs, out_shape, order='bilinear', return_footprint=False)
    if shift_to is None:
        return psf_rot

    print('Shifting PSFs to match the centroids...')
    psf_rotshift = np.zeros(psf_rot.shape)
    if len(shift_to.shape) > 2:
        data = np.nansum(shift_to, axis=0)
    else:
        data = shift_to
    cent0 = photutils.centroids.centroid_com(data)
    if shift_wcs is not None:
        cent0 = out_wcs.world_to_pixel(shift_wcs.pixel_to_world(*cent0))

    if len(psf_rot.shape) > 2:
        for i in tqdm.trange(psf_rot.shape[0]):
            # cent0 = photutils.centroids.centroid_com(shift_to['SCI'].data[i, box[0]:box[1], box[2]:box[3]]) + np.array([box[2]+0.5, box[0]+0.5])
            cent1 = photutils.centroids.centroid_com(psf_rot[i, :, :])
            shift = cent0 - cent1
            psf_rotshift[i,:,:] = ndimage.shift(psf_rot[i,:,:], shift[::-1], order=1, mode='constant', cval=0.)
    else:
        cent1 = photutils.centroids.centroid_com(psf_rot)
        shift = cent0 - cent1
        psf_rotshift = ndimage.shift(psf_rot, shift[::-1], order=1, mode='constant', cval=0.)

    return psf_rotshift


def calculate_extended_emission(ifu_cubes, params, line_dict):
    """
    Loop through all line fluxes in the parameter maps and calculate separated nuclear (point-like) flux from
    extended flux using the PSF. Creates new HDUs for both of the separated fluxes.

    :param ifu_cubes: dict
        A dictionary of FITS HDULists for each MIRI channel/band. Should be IFU-aligned axes. These are used to
        calculate the position of the point source and the rotation between the IFU axes and sky axes.
    :param params: HDUList
        The parameter maps containing the line fluxes that should be corrected.
    :param line_dict: dict
        A dictionary containing the rest wavelengths of the lines.
    """

    z = params[0].header['REDSHIFT']
    
    ch_dict = {'1A': (4.90, 5.74),
               '1B': (5.66, 6.63),
               '1C': (6.53, 7.65),
               '2A': (7.51, 8.77),
               '2B': (8.67, 10.13),
               '2C': (10.02, 11.70),
               '3A': (11.55, 13.47),
               '3B': (13.34, 15.57),
               '3C': (15.41, 17.98),
               '4A': (17.70, 20.95),
               '4B': (20.69, 24.48),
               '4C': (24.19, 27.90)}
    
    out_wcs = WCS(params[0].header)[0]
    out_shape = params[1].data.shape
    names = [param.name for param in params]

    print('Adding HDUs for pointlike and extended emission...')
    # Get list of all lines to be included
    lines = np.array([], dtype=str)
    for key in line_dict['lines'].keys():
        for name in names:
            if (key.upper() in name) and (key not in lines):
                lines = np.append(lines, key)

    for line_name in lines:
        line_wave = line_dict['lines'][line_name]['wave']
        line_wave *= (1+z)
        line_param = 'FLUX'
        j = 1
        # Search for line components until we dont find any 
        flux = np.zeros(params[1].data.shape)
        while True:
            try:
                data_i = 10**params[f'LINES_{line_name.upper()}_{j}_{line_param}'].data
                data_i[~np.isfinite(data_i)] = 0.
                flux += data_i
                j += 1
            except:
                break

        # Get the MIRI Channel/Band that this falls under
        chbands = []
        centroids = []
        for key, val in ch_dict.items():
            if val[0] < line_wave < val[1]:
                chbands.append(key)
                hdr = ifu_cubes[key][1].header
                wave_full = hdr["CRVAL3"] + hdr["CDELT3"] * (hdr["CRPIX3"] + np.arange(hdr["NAXIS3"]) - 1)
                wave_slice = np.nanargmin(np.abs(wave_full - line_wave))
                # centroid_frame1 = np.unravel_index(np.nanargmax(flux), flux.shape)[::-1]
                centroid_frame1 = photutils.centroids.centroid_2dg(flux, mask=~np.isfinite(flux))
                centroid_frame2 = WCS(ifu_cubes[key][1].header)[0].world_to_pixel(out_wcs.pixel_to_world(*centroid_frame1))
                centroids.append(centroid_frame2)

        # Generate PSFs for each channel/band
        psfs = []
        print(f'Calculating {len(chbands)} PSFs for LINES_{line_name.upper()}_1_{line_param}')
        for (centroid, chband) in zip(centroids, chbands):
            psf = calculate_mrs_psf(ifu_cubes[chband], centroid=None, wave=line_wave, out_wcs=out_wcs, out_shape=out_shape, 
                                    shift_to=ifu_cubes[chband][1].data[max(0,wave_slice-50):min(wave_slice+50,ifu_cubes[chband][1].data.shape[0]), :, :], 
                                    shift_wcs=WCS(ifu_cubes[chband][1].header)[0])
            psfs.append(psf)

        # For lines that happen to fall on the channel boundaries, average the two PSFs
        if len(psfs) > 1:
            psf = np.nanmean(psfs, axis=0)
        else:
            psf = psfs[0]

        # Renormalize the PSF
        psf /= np.nanmax(psf)

        # Apply PSF correction and redo the log
        flux_nuc = np.nanmax(flux)
        flux_point = np.log10(psf*flux_nuc)
        flux_ext = np.log10(flux - psf*flux_nuc)

        # Make a new HDU with the corrected flux
        if f'LINES_{line_name.upper()}_1_FLUX_POINT' not in names:
            flux_point = fits.ImageHDU(flux_point, params[f'LINES_{line_name.upper()}_1_FLUX'].header, 
                                       name=f'LINES_{line_name.upper()}_1_FLUX_POINT')
            params.append(flux_point)
        else:
            params[f'LINES_{line_name.upper()}_1_FLUX_POINT'].data = flux_point
        if f'LINES_{line_name.upper()}_1_FLUX_EXTENDED' not in names:
            flux_ext = fits.ImageHDU(flux_ext, params[f'LINES_{line_name.upper()}_1_FLUX'].header, 
                                     name=f'LINES_{line_name.upper()}_1_FLUX_EXTENDED')
            params.append(flux_ext)
        else:
            params[f'LINES_{line_name.upper()}_1_FLUX_EXTENDED'].data = flux_ext

    return params


if __name__ == '__main__':

    # Inputs: file paths to (1) IFU-aligned single-channel single-band level 3 reduced cubes,
    #                       (2) Parameter maps FITS file (if editing already-fit data) OR LOKI-formatted input data (if generating full PSF models)
    #                       (3) OPTIONAL, string giving the channel/band (i.e. '2B') if generating full PSF models
    ifu_path = sys.argv[1]
    param_path = sys.argv[2]
    try:
        just_psf = sys.argv[3]
    except:
        just_psf = ''

    line_dict_path = os.path.join(os.path.dirname(__file__), '..', 'src', 'options', 'lines.toml')

    # Get IFU-aligned cubes for each subchannel
    print('Loading in FITS data...')
    ifu_cubes = {'1A': fits.open(os.path.join(ifu_path, 'Level3_ch1-short_s3d.fits')),
                 '1B': fits.open(os.path.join(ifu_path, 'Level3_ch1-medium_s3d.fits')),
                 '1C': fits.open(os.path.join(ifu_path, 'Level3_ch1-long_s3d.fits')),
                 '2A': fits.open(os.path.join(ifu_path, 'Level3_ch2-short_s3d.fits')),
                 '2B': fits.open(os.path.join(ifu_path, 'Level3_ch2-medium_s3d.fits')),
                 '2C': fits.open(os.path.join(ifu_path, 'Level3_ch2-long_s3d.fits')),
                 '3A': fits.open(os.path.join(ifu_path, 'Level3_ch3-short_s3d.fits')),
                 '3B': fits.open(os.path.join(ifu_path, 'Level3_ch3-medium_s3d.fits')),
                 '3C': fits.open(os.path.join(ifu_path, 'Level3_ch3-long_s3d.fits')),
                 '4A': fits.open(os.path.join(ifu_path, 'Level3_ch4-short_s3d.fits')),
                 '4B': fits.open(os.path.join(ifu_path, 'Level3_ch4-medium_s3d.fits')),
                 '4C': fits.open(os.path.join(ifu_path, 'Level3_ch4-long_s3d.fits'))}

    # Get the parameter maps from the fitting
    params = fits.open(param_path, mode='update')
    # Get the line dictionary so we can get rest wavelengths based on the HDU names
    line_dict = toml.load(line_dict_path)

    if just_psf:
        if not os.path.exists(f'psf_model_ch{just_psf}_norm.fits'):
            # Calculate the PSFs
            psfs = calculate_mrs_psf(ifu_cubes[just_psf])
            # Save as FITS file
            hdul = fits.HDUList([fits.PrimaryHDU(psfs, ifu_cubes[just_psf][1].header)])
            hdul.writeto(f'psf_model_ch{just_psf}_norm.fits', overwrite=True)
            hdul.close()
        else:
            psfs = fits.open(f'psf_model_ch{just_psf}_norm.fits')[0].data

        in_wcs = WCS(ifu_cubes[just_psf][1].header)[0]
        out_wcs = WCS(params[1].header)[0]
        out_shape = (ifu_cubes[just_psf][1].data.shape[0], *params[1].data.shape[1:])

        psfs_rotshift = rotate_and_shift(psfs, in_wcs, out_wcs, out_shape, shift_to=params['SCI'].data)
        hdul = fits.HDUList([fits.PrimaryHDU(header=params[0].header)])
        hdul.append(fits.ImageHDU(psfs_rotshift, params[1].header, name='SCI'))
        hdul.append(fits.ImageHDU(np.zeros(psfs_rotshift.shape), params[2].header, name='ERR'))
        hdul.append(fits.ImageHDU(np.zeros(psfs_rotshift.shape, dtype=np.uint16), params[2].header, name='DQ'))
        # wavecol = fits.Column(name='wave', format='1D', array=params['AUX'].data['wave'])
        # psfcol = fits.Column(name='psf', format='1D', array=params['AUX'].data['psf'])
        # lsfcol = fits.Column(name='lsf', format='1D', array=params['AUX'].data['lsf'])
        # cols = fits.ColDefs([wavecol, psfcol, lsfcol])
        # hdul.append(fits.BinTableHDU.from_columns(cols))
        hdul.writeto(f'psf_model_ch{just_psf}_norm_rot_shift.fits', overwrite=True, output_verify='warn')
        hdul.close()

    else:
        params = calculate_extended_emission(ifu_cubes, params, line_dict)

        # Write changes to the file and close
        params.flush()
        params.close()
        for val in ifu_cubes.values():
            val.close()
